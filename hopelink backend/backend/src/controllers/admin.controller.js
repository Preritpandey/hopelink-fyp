import { StatusCodes } from 'http-status-codes';
import Organization from '../models/organization.model.js';
import User from '../models/user.model.js';
import { BadRequestError, NotFoundError } from '../errors/index.js';
import { generateRandomPassword } from '../utils/helpers.js';
import { sendEmail, emailTemplates } from '../services/email.service.js';
import mongoose from 'mongoose';

// @desc    Get all organizations with optional filtering
// @route   GET /api/admin/orgs
// @access  Private/Admin
export const getAllOrganizations = async (req, res) => {
  try {
    const { status } = req.query;
    const query = {};
    
    if (status) {
      query.status = status;
    }

    const organizations = await Organization.find(query)
      .populate({
        path: 'user',
        select: 'email name',
        model: 'User'
      })
      .populate({
        path: 'approvedBy',
        select: 'name email',
        model: 'User'
      })
      .sort({ createdAt: -1 });

    res.status(StatusCodes.OK).json({
      success: true,
      count: organizations.length,
      data: organizations,
    });
  } catch (error) {
    console.error('Error in getAllOrganizations:', error);
    res.status(StatusCodes.INTERNAL_SERVER_ERROR).json({
      success: false,
      error: {
        message: 'Error fetching organizations',
        details: error.message
      }
    });
  }
};

// @desc    Get pending organizations
// @route   GET /api/admin/orgs/pending
// @access  Private/Admin
export const getPendingOrganizations = async (req, res) => {
  try {
    const organizations = await Organization.find({ status: 'pending' })
      .populate({
        path: 'user',
        select: 'email name',
        model: 'User'
      })
      .sort({ createdAt: -1 });

    res.status(StatusCodes.OK).json({
      success: true,
      count: organizations.length,
      data: organizations,
    });
  } catch (error) {
    console.error('Error in getPendingOrganizations:', error);
    res.status(StatusCodes.INTERNAL_SERVER_ERROR).json({
      success: false,
      error: {
        message: 'Error fetching pending organizations',
        details: error.message
      }
    });
  }
};

// @desc    Approve organization
// @route   PUT /api/admin/orgs/approve/:id
// @access  Private/Admin
// @desc    Approve organization
// @route   PUT /api/admin/orgs/approve/:id
// @access  Private/Admin
export const approveOrganization = async (req, res) => {
  const { id } = req.params;
  
  try {
    // Verify admin is authenticated
    if (!req.user || !req.user._id) {
      console.error('Authentication error: No user found in request');
      return res.status(StatusCodes.UNAUTHORIZED).json({
        success: false,
        error: 'Authentication required. Please log in as an admin.'
      });
    }

    const adminUser = await User.findById(req.user._id);
    if (!adminUser || adminUser.role !== 'admin') {
      console.error('Authorization error: User is not an admin', { userId: req.user._id });
      return res.status(StatusCodes.FORBIDDEN).json({
        success: false,
        error: 'Unauthorized. Admin privileges required.'
      });
    }

    const organization = await Organization.findById(id);
    console.log("Organization approval request:", { 
      organizationId: id, 
      requestedBy: req.user._id,
      organizationStatus: organization?.status 
    });
    
    if (!organization) {
      console.error('Organization not found:', id);
      throw new NotFoundError('Organization not found');
    }

    if (organization.status !== 'pending') {
      console.warn('Organization is not in pending status:', { 
        currentStatus: organization.status,
        organizationId: id 
      });
      throw new BadRequestError('Organization is not in pending status');
    }

    let password = null;
    let user = null;
    
    // Check if organization already has a linked user
    if (organization.user) {
         user = await User.findById(organization.user);
    }
    
    if (!user) {
        // Try finding by email if not linked or linked user not found
        user = await User.findOne({ email: organization.officialEmail });
    }

    if (user) {
        // User exists (either linked or found by email)
        console.log("Found existing user", user._id);
        
        // Link if not already linked
        if (!organization.user || organization.user.toString() !== user._id.toString()) {
            organization.user = user._id;
        }
        
        user.isVerified = true;
        user.role = 'organization'; // Upgrade role
        user.organization = organization._id; // Link user to organization
        
        if (user.isPasswordAutogenerated) {
             password = generateRandomPassword(12);
             user.password = password;
             await sendApprovalEmail(organization, password);
        } else {
             await sendApprovalEmailExistingUser(organization);
        }

        await user.save();

    } else {
         // Create new user
        console.log("Creating new user for organization");
        password = generateRandomPassword(12);
        user = new User({
          name: organization.representativeName,
          email: organization.officialEmail,
          password: password,
          role: 'organization',
          organization: organization._id, // Link user to organization
          isVerified: true,
          isPasswordAutogenerated: true
        });
        await user.save();
        
        organization.user = user._id;
        await sendApprovalEmail(organization, password);
    }

    // Update organization status
    organization.status = 'approved';
    organization.isVerified = true;
    organization.approvedBy = req.user._id;
    organization.approvedAt = new Date();
    
    // Save organization changes
    await organization.save();
    
    console.log('Organization approved successfully', { 
      organizationId: organization._id,
      userId: user?._id 
    });
    
    res.status(StatusCodes.OK).json({
      success: true,
      message: 'Organization approved successfully',
      data: {
        organizationId: organization._id,
        userId: user?._id,
        email: organization.officialEmail,
        status: 'approved'
      },
    });
  } catch (error) {
    console.error('Error in approveOrganization:', error);
    
    // Handle duplicate key error specifically
    if (error.code === 11000) {
      return res.status(StatusCodes.CONFLICT).json({
        success: false,
        error: {
          message: 'A user with this email already exists',
          details: 'Please link the existing user account or use a different email'
        }
      });
    }
    
    res.status(StatusCodes.INTERNAL_SERVER_ERROR).json({
      success: false,
      error: {
        message: 'Error approving organization',
        details: error.message
      }
    });
  }
};

// @desc    Reject organization
// @route   PUT /api/admin/orgs/reject/:id
// @access  Private/Admin
export const rejectOrganization = async (req, res) => {
  const { id } = req.params;
  const { reason } = req.body;

  try {
    const organization = await Organization.findById(id);
    
    if (!organization) {
      throw new NotFoundError('Organization not found');
    }

    if (organization.status !== 'pending') {
      throw new BadRequestError('Organization is not in pending status');
    }

    // Update organization status
    organization.status = 'rejected';
    organization.rejectionReason = reason || 'No reason provided';
    organization.approvedBy = req.user.userId;
    organization.approvedAt = new Date();
    
    await organization.save();

    // Populate the organization with user data for response
    const populatedOrg = await Organization.findById(organization._id)
      .populate('user', 'email name')
      .populate('approvedBy', 'name email');

    // Send rejection email if organization has an email
    if (organization.officialEmail) {
      try {
        const emailData = {
          to: organization.officialEmail,
          subject: 'Your Organization Registration Has Been Rejected',
          template: 'organization-rejected',
          context: {
            organizationName: organization.organizationName,
            reason: organization.rejectionReason,
            contactEmail: process.env.SUPPORT_EMAIL || 'support@hopelink.com',
          },
        };
        await sendEmail(emailData);
      } catch (emailError) {
        console.error('Error sending rejection email:', emailError);
        // Continue even if email fails
      }
    }

    res.status(StatusCodes.OK).json({
      success: true,
      message: 'Organization rejected successfully',
      data: populatedOrg,
    });
  } catch (error) {
    console.error('Error rejecting organization:', error);
    res.status(StatusCodes.INTERNAL_SERVER_ERROR).json({
      success: false,
      error: {
        message: 'Error rejecting organization',
        details: error.message
      }
    });
  }
};

// Helper function to send approval email with password (new user)
const sendApprovalEmail = async (organization, password) => {
  try {
    const emailData = {
      email: organization.officialEmail,
      organizationName: organization.organizationName,
      password: password,
      representativeName: organization.representativeName
    };
    
    await sendEmail(emailTemplates.organizationApproved(emailData));
    console.log(`Approval email sent to ${organization.officialEmail}`);
  } catch (err) {
    console.error('Failed to send approval email:', err);
    throw err; // Re-throw to handle in the main function
  }
};

// Helper function to send approval email for existing user (no password)
const sendApprovalEmailExistingUser = async (organization) => {
  try {
    const emailData = {
      email: organization.officialEmail,
      organizationName: organization.organizationName,
      representativeName: organization.representativeName
    };
    
    await sendEmail(emailTemplates.organizationApproved(emailData));
    console.log(`Approval email sent to ${organization.officialEmail}`);
  } catch (err) {
    console.error('Failed to send approval email:', err);
    throw err;
  }
};